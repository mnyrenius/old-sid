#ifndef _OLED_H_
#define _OLED_H_

#include "avr_types.h"
#include <string.h>
#include <stdlib.h>
#include <avr/pgmspace.h>

const uint8_t ASCII[][5] PROGMEM = 
{
  { 0x00, 0x00, 0x00, 0x00, 0x00 } // 20   (space)
  ,{ 0x00, 0x00, 0x5f, 0x00, 0x00 } // 21 !
  ,{ 0x00, 0x07, 0x00, 0x07, 0x00 } // 22 "
  ,{ 0x14, 0x7f, 0x14, 0x7f, 0x14 } // 23 #
  ,{ 0x24, 0x2a, 0x7f, 0x2a, 0x12 } // 24 $
  ,{ 0x23, 0x13, 0x08, 0x64, 0x62 } // 25 %
  ,{ 0x36, 0x49, 0x55, 0x22, 0x50 } // 26 &
  ,{ 0x00, 0x05, 0x03, 0x00, 0x00 } // 27 '
  ,{ 0x00, 0x1c, 0x22, 0x41, 0x00 } // 28 (
  ,{ 0x00, 0x41, 0x22, 0x1c, 0x00 } // 29 )
  ,{ 0x14, 0x08, 0x3e, 0x08, 0x14 } // 2a *
  ,{ 0x08, 0x08, 0x3e, 0x08, 0x08 } // 2b +
  ,{ 0x00, 0x50, 0x30, 0x00, 0x00 } // 2c ,
  ,{ 0x08, 0x08, 0x08, 0x08, 0x08 } // 2d -
  ,{ 0x00, 0x60, 0x60, 0x00, 0x00 } // 2e .
  ,{ 0x20, 0x10, 0x08, 0x04, 0x02 } // 2f /
  ,{ 0x3e, 0x51, 0x49, 0x45, 0x3e } // 30 0
  ,{ 0x00, 0x42, 0x7f, 0x40, 0x00 } // 31 1
  ,{ 0x42, 0x61, 0x51, 0x49, 0x46 } // 32 2
  ,{ 0x21, 0x41, 0x45, 0x4b, 0x31 } // 33 3
  ,{ 0x18, 0x14, 0x12, 0x7f, 0x10 } // 34 4
  ,{ 0x27, 0x45, 0x45, 0x45, 0x39 } // 35 5
  ,{ 0x3c, 0x4a, 0x49, 0x49, 0x30 } // 36 6
  ,{ 0x01, 0x71, 0x09, 0x05, 0x03 } // 37 7
  ,{ 0x36, 0x49, 0x49, 0x49, 0x36 } // 38 8
  ,{ 0x06, 0x49, 0x49, 0x29, 0x1e } // 39 9
  ,{ 0x00, 0x36, 0x36, 0x00, 0x00 } // 3a :
  ,{ 0x00, 0x56, 0x36, 0x00, 0x00 } // 3b ;
  ,{ 0x08, 0x14, 0x22, 0x41, 0x00 } // 3c <
  ,{ 0x14, 0x14, 0x14, 0x14, 0x14 } // 3d =
  ,{ 0x00, 0x41, 0x22, 0x14, 0x08 } // 3e >
  ,{ 0x02, 0x01, 0x51, 0x09, 0x06 } // 3f ?
  ,{ 0x32, 0x49, 0x79, 0x41, 0x3e } // 40 @
  ,{ 0x7e, 0x11, 0x11, 0x11, 0x7e } // 41 A
  ,{ 0x7f, 0x49, 0x49, 0x49, 0x36 } // 42 B
  ,{ 0x3e, 0x41, 0x41, 0x41, 0x22 } // 43 C
  ,{ 0x7f, 0x41, 0x41, 0x22, 0x1c } // 44 D
  ,{ 0x7f, 0x49, 0x49, 0x49, 0x41 } // 45 E
  ,{ 0x7f, 0x09, 0x09, 0x09, 0x01 } // 46 F
  ,{ 0x3e, 0x41, 0x49, 0x49, 0x7a } // 47 G
  ,{ 0x7f, 0x08, 0x08, 0x08, 0x7f } // 48 H
  ,{ 0x00, 0x41, 0x7f, 0x41, 0x00 } // 49 I
  ,{ 0x20, 0x40, 0x41, 0x3f, 0x01 } // 4a J
  ,{ 0x7f, 0x08, 0x14, 0x22, 0x41 } // 4b K
  ,{ 0x7f, 0x40, 0x40, 0x40, 0x40 } // 4c L
  ,{ 0x7f, 0x02, 0x0c, 0x02, 0x7f } // 4d M
  ,{ 0x7f, 0x04, 0x08, 0x10, 0x7f } // 4e N
  ,{ 0x3e, 0x41, 0x41, 0x41, 0x3e } // 4f O
  ,{ 0x7f, 0x09, 0x09, 0x09, 0x06 } // 50 P
  ,{ 0x3e, 0x41, 0x51, 0x21, 0x5e } // 51 Q
  ,{ 0x7f, 0x09, 0x19, 0x29, 0x46 } // 52 R
  ,{ 0x46, 0x49, 0x49, 0x49, 0x31 } // 53 S
  ,{ 0x01, 0x01, 0x7f, 0x01, 0x01 } // 54 T
  ,{ 0x3f, 0x40, 0x40, 0x40, 0x3f } // 55 U
  ,{ 0x1f, 0x20, 0x40, 0x20, 0x1f } // 56 V
  ,{ 0x3f, 0x40, 0x38, 0x40, 0x3f } // 57 W
  ,{ 0x63, 0x14, 0x08, 0x14, 0x63 } // 58 X
  ,{ 0x07, 0x08, 0x70, 0x08, 0x07 } // 59 Y
  ,{ 0x61, 0x51, 0x49, 0x45, 0x43 } // 5a Z
  ,{ 0x00, 0x7f, 0x41, 0x41, 0x00 } // 5b [
  ,{ 0x02, 0x04, 0x08, 0x10, 0x20 } // 5c backslash
  ,{ 0x00, 0x41, 0x41, 0x7f, 0x00 } // 5d ]
  ,{ 0x04, 0x02, 0x01, 0x02, 0x04 } // 5e ^
  ,{ 0x40, 0x40, 0x40, 0x40, 0x40 } // 5f _
  ,{ 0x00, 0x01, 0x02, 0x04, 0x00 } // 60 `
  ,{ 0x20, 0x54, 0x54, 0x54, 0x78 } // 61 a
  ,{ 0x7f, 0x48, 0x44, 0x44, 0x38 } // 62 b
  ,{ 0x38, 0x44, 0x44, 0x44, 0x20 } // 63 c
  ,{ 0x38, 0x44, 0x44, 0x48, 0x7f } // 64 d
  ,{ 0x38, 0x54, 0x54, 0x54, 0x18 } // 65 e
  ,{ 0x08, 0x7e, 0x09, 0x01, 0x02 } // 66 f
  ,{ 0x0c, 0x52, 0x52, 0x52, 0x3e } // 67 g
  ,{ 0x7f, 0x08, 0x04, 0x04, 0x78 } // 68 h
  ,{ 0x00, 0x44, 0x7d, 0x40, 0x00 } // 69 i
  ,{ 0x20, 0x40, 0x44, 0x3d, 0x00 } // 6a j 
  ,{ 0x7f, 0x10, 0x28, 0x44, 0x00 } // 6b k
  ,{ 0x00, 0x41, 0x7f, 0x40, 0x00 } // 6c l
  ,{ 0x7c, 0x04, 0x18, 0x04, 0x78 } // 6d m
  ,{ 0x7c, 0x08, 0x04, 0x04, 0x78 } // 6e n
  ,{ 0x38, 0x44, 0x44, 0x44, 0x38 } // 6f o
  ,{ 0x7c, 0x14, 0x14, 0x14, 0x08 } // 70 p
  ,{ 0x08, 0x14, 0x14, 0x18, 0x7c } // 71 q
  ,{ 0x7c, 0x08, 0x04, 0x04, 0x08 } // 72 r
  ,{ 0x48, 0x54, 0x54, 0x54, 0x20 } // 73 s
  ,{ 0x04, 0x3f, 0x44, 0x40, 0x20 } // 74 t
  ,{ 0x3c, 0x40, 0x40, 0x20, 0x7c } // 75 u
  ,{ 0x1c, 0x20, 0x40, 0x20, 0x1c } // 76 v
  ,{ 0x3c, 0x40, 0x30, 0x40, 0x3c } // 77 w
  ,{ 0x44, 0x28, 0x10, 0x28, 0x44 } // 78 x
  ,{ 0x0c, 0x50, 0x50, 0x50, 0x3c } // 79 y
  ,{ 0x44, 0x64, 0x54, 0x4c, 0x44 } // 7a z
  ,{ 0x00, 0x08, 0x36, 0x41, 0x00 } // 7b {
  ,{ 0x00, 0x00, 0x7f, 0x00, 0x00 } // 7c |
  ,{ 0x00, 0x41, 0x36, 0x08, 0x00 } // 7d }
,{ 0x10, 0x08, 0x08, 0x10, 0x08 } // 7e ~
,{ 0x78, 0x46, 0x41, 0x46, 0x78 } // 7f DEL
}; 
   
const uint8_t oled_dc     = PD4;
const uint8_t oled_cs     = PD5;

struct Device
{
  static void spi_transfer (uint8_t dc, uint8_t data)
  {
    if (dc == 0)
    {
      bit::clear (PORTD, oled_dc);
    }

    else
    {
      bit::set (PORTD, oled_dc);
    }

    bit::clear (PORTD, oled_cs);

    SPDR = data;
    while (!(SPSR & (1 << SPIF)));

    bit::set (PORTD, oled_cs);
  }

  static void command (uint8_t command)
  {
    spi_transfer (0, command);
  }

  static void data (uint8_t data)
  {
    spi_transfer (1, data);
  }
};  

class Oled
{
  public:
    Oled ()
    {
      //memset (_screen, 0, 128);
    }

    ~Oled ()
    {
    }

    void init ()
    {
      Device::command (0x0ae);       
      Device::command (0x0d5);
      Device::command (0x080);
      Device::command (0x0a8);
      Device::command (0x03f);
      Device::command (0x0d3);
      Device::command (0x000);
      Device::command (0x040);       
      Device::command (0x08d);
      Device::command (0x014);
      Device::command (0x020);
      Device::command (0x000);
      Device::command (0x0a1);       
      Device::command (0x0c8);       
      Device::command (0x0da);
      Device::command (0x012);
      Device::command (0x081);
      Device::command (0x0cf);
      Device::command (0x0d9);
      Device::command (0x0f1);
      Device::command (0x0db);
      Device::command (0x040);
      Device::command (0x02e);       
      Device::command (0x0a4);       
      Device::command (0x0a6);
    }

    void off ()
    {
      Device::command (0x0ae);       
    }

    void on ()
    {
      Device::command (0x0af);     
    }

    void clear ()
    {
      for (uint8_t page = 0; page < 64/8; page++) 
      {
        for (uint8_t col = 2; col < 130; col++) 
        {
          Device::command(0xb0 + page);
          Device::command(col & 0xf);
          Device::command(0x10 | (col >> 4));
          Device::data (0);
        }
      } 

      //memset (_screen, 0, 128);
    }

    void set_contrast (uint8_t contrast)
    {
    }

    void write_text (uint8_t x, uint8_t y, const char * text, uint8_t len, bool inverted = false)
    {
      uint8_t col = x;
      uint8_t buffer[5];

      for (uint8_t i = 0; i < len; ++i) 
      {
        memcpy_P (buffer, ASCII[text[i] - 0x20], 5);
        Device::command(0xb0 + y);
        Device::command(col & 0xf);
        Device::command(0x10 | (col >> 4));

        if (inverted)
        { 
          Device::data (~buffer[0]);
          Device::data (~buffer[1]);
          Device::data (~buffer[2]);
          Device::data (~buffer[3]);
          Device::data (~buffer[4]);
          Device::data (0xff);
        }

        else
        {
          Device::data (buffer[0]);
          Device::data (buffer[1]);
          Device::data (buffer[2]);
          Device::data (buffer[3]);
          Device::data (buffer[4]);
          Device::data (0);
        }

        col += 6;
      } 
      /*
      for (int i = 0; i < len; ++i)
      {
        memcpy_P (_screen + x + (i * 6) + y * 128, ASCII[text[i] - 0x20], 5);
      }
      */
    }

    /*
    template<int N>
    void write_text (uint8_t x, uint8_t y, const char (&text)[N], bool inverted = false)
    {
      write_text (x, y, text, N, inverted);
      Device::command(0xb0 + 0);
      Device::command(col & 0xf);
      Device::command(0x10 | (col >> 4));
      Device::data (ASCII['N'][0]); 
      Device::data (ASCII['N'][1]); 
      Device::data (ASCII['N'][2]); 
      Device::data (ASCII['N'][3]); 
      Device::data (ASCII['N'][4]);
    } 
*/

    void write_text (uint8_t x, uint8_t y, const char * text, bool inverted = false)
    {
      write_text (x, y, text, strlen (text), inverted);
    }

    void write_number (uint8_t x, uint8_t y, int16_t n)
    {
      char buffer[5];
      itoa (n, buffer, 10);
      write_text (x, y, buffer);
    }

    void render ()
    {
      /*
      for (uint8_t page = 0; page < 64/8; page++) 
      {
        for (uint8_t col = 2; col < 130; col++) 
        {
          Device::command(0xb0 + page);
          Device::command(col & 0xf);
          Device::command(0x10 | (col >> 4));
          Device::data (_screen[col - 2 + page * 128]);
        }
      } 
      */
    }

  private:
    atm8::pin _dc;
    atm8::pin _cs;
};

#endif /* _OLED_H_ */
